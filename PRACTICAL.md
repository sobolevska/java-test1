# Start IT Java group practical test
2019-04-05

You can do the tasks in any order you please and organize the work hovever is most convenient to you. The only thing that matters is that all solutions should be visible inside your repository. Either as different projects and/or files, or as separate versions (commits) of the same file/project.

### Welcome, young grasshopper!

Today you will create your own start-up business. *(Wait, wasn't this about programming or something?)*

My name is Tom and I will be your personal assistant on this journey.
Like any good story, yours will also require a lot of logical thinking and problem solving skills.
Your tools for the job are your brain and the Java programming language.
As you encounter problems, think about them in an abstract manner, break them down into steps and sub-problems,
 and apply the toolset you have acquired over the last 1.5 weeks.

Godspeed!

### Task 1: Grand opening!

It is the first day of your new business. Time to do a grand opening!
Sadly the robot that you hired to do meet-and-greet is broken.
The main module is missing and it is up to you to write the core functionality and save the opening ceremony.

Create an application that:
- greets the user and asks for their name
- politely echoes the user's name back, and invites them into the opening ceremony

### Task 2: Admision

The potential clients are now piling in, and it is becoming painfully obvious,
that the rented room will soon become too small, as it can only house 100 people.
It would be impolite from *us* to turn people away, so let's make a program that does the dirty work for us.

Create an appliction that:
- reads as input: the amount of people in the room
- reads as input: the amount of people still in the queue
- prints if every person in the queue can fit in the room

#### Examples:
input1|input2|output
:-:|:-:|:-
`60`|`27`|`can fit`
`88`|`13`|`can't fit`

### Task 2 (extra):
Instead of just printing if everyone can make it, print for every person in the queue, if they can make it in

#### Examples:
input1|input2|output
:-:|:-:|:-
`54`|`3`|`fit`<br>`fit`<br>`fit`
`98`|`5`|`fit`<br>`fit`<br>`can't fit`<br>`can't fit`<br>`can't fit`

### Task 3: A Visual Update

The grand opening day is over and went great! While interacting with potential customers, we got a lot of ideas,
 for example, about a new logo. Supposedly, you can draw pretty spirals by using the Fibonacci sequence as a guide.
  The Fibonacci sequence is a sequence of numbers where each new number is generated by adding the two previous numbers.
   The first few Fibonacci numbers are: `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, .... etc.`
    To create a really beautiful spiral-logo, the designer needs at least 1000 Fibonacci numbers for reference.

Create an application that:
- prints 1000 Fibonacci numbers

_(if you are curious, after the test you can learn more about the Fibonacci spiral here: https://en.wikipedia.org/wiki/Fibonacci_number )_

### Task 4: Branding

Now that we have a hip logo, let's work on our business name. Nowadays all cool brand names are palindromes - words or sentences that read the same from both ends. For example: "level", "step on no pets". We should make our company name palindromic as well, and we should do it quick!

Create an application that:
- prints if your user input is a palindrome or not

#### Examples:
input|output
:-|:-:
`Amazon`|`no`
`Amazama`|`yes`

**Note:** Java is case-sensitive by default, and by default will consider, say, `E` to be different from `e`

### Task 5: Mobile market

With the brand all set up, you decided to make a run in the smartphone app market. You outsourced the development of your mobile app, but of course the company tasked with it was incompetent. Credit card encryption is seriously flawed and it is up to you to fix it. You decide to pick the current top-notch encryption algorithm which goes like this:

Looking at the credit card number digit-by-digit create a single "hash" by summing together all digits that are followed by the same digit.

Create an application that:
- lets the user input their credit card number
- outputs the hash

#### Examples:
input|output|comments
:-|:-:|:-
`1122`|`3`|1 + 2, because the first digit (1) matches the second and the third digit (2) matches the fourth
`22-22`|`4`|2+2, because the first `2` mathces the second and the third `2` matches the fourth
`1234`|`0`|because no number matches the next one
`HA-91212199`|`9`|because only the second-to-last `9` has a match

### Task 5 (extra):

To increase security ignore any letters and dashes, and also consider the card number to "loop" around itself (a.k.a.imagine that the first digit follows the last one).

#### Examples:
input|output|comments
:-|:-:|:-
`1122`|`3`|nothing changes
`22-22`|`8`|2+2+2+2, because now every single `2` has another `2` that follows
`1234`|`0`|nothing changes
`HA-91212199`|`18`|the second-to-last `9` has a match and also, the last `9` matches the `9` that's at the start

### Task 6: A glitch

Oh, no! The mobile app is so successfull that hackers are now targeting it! They are using a vulnerability that exploits unmatched parenthesis! We must add an extra layer of security!

Create an application that:
- lets the user input a string of parenthesis
- outputs if it is properly matched or not

#### Examples:
input|output|comments
:-|:-:|:-
`()`|`valid`|a single pair of matching parenthesis
`(()())`|`valid`|inner pairs of parenthesis match and there is a matching outer pair
`((()())`|`invalid`|there is one unmatched opened parenthesis
`(()()(((()))()))`|`valid`|
`((()()))))()`|`invalid`|there are a few unmatched closing parenthesis

### Task 7: The aftermath

The product is now protected. Let's try to catch the hacker.
They were careless and left a signature that could be used to identify them, but it is compressed in a unique format.

The format compresses a sequence of characters. Whitespace is ignored. To indicate that some sequence should be repeated, a marker is added to the text, like (10x2). To decompress this marker, take the subsequent 10 characters and repeat them 2 times. Then, continue reading the input after the repeated data. The marker itself is not included in the decompressed output.

If parentheses or other characters appear within the data referenced by a marker, that's okay - treat it like normal data, not a marker, and then resume looking for markers after the decompressed section.

Create an application that:
- reads a compressed sequence of characters
- outputs the decompressed version of it

#### Examples:
input|output|comments
:-|:-|:-
`ACNTR`|`ACNTR`|contains no markers, so it decompresses with no changes
`A(1x5)BC`|`ABBBBBC`|repeats the single symbol `B` for a total of 5 times
`(3x2)XYZ`|`XYZXYZ`|repeats the three characters two times
`A(2x2)BCD(2x2)EFG`|`ABCBCDEFEFG`|doubles the `BC` and then doubles the `EF`
`(6x1)(1x3)A`|`(1x3)A`|the `(1x3)` looks like a marker, but because it's within a data section of another marker, it is not treated any differently from the `A` that comes after it
`X(8x2)(3x3)ABCY`|`X(3x3)ABC(3x3)ABCY`|putting all the cases together

### Task 7 (extra):
If the decompressed output contains any markers, decompress those as well.

#### Examples:
input|output|comments
:-|:-|:-
`ACNTR`|`ACNTR`|same
`A(1x5)BC`|`ABBBBBC`|same
`(3x2)XYZ`|`XYZXYZ`|same
`A(2x2)BCD(2x2)EFG`|`ABCBCDEFEFG`|same
`(6x1)(1x3)A`|`AAA`|last time we left the `(1x3)A` alone, but now we continue with the decompression 
`X(8x2)(3x3)ABCY`|`XABCABCABCABCABCABCY`|decompressing the `(3x3)ABC` that we get in the first iteration
`X(14x2)F(8x2)(3x3)ABCY`|`XFABCABCABCABCABCABCFABCABCABCABCABCABCY`|here are the intermediate steps:<br>`XF(8x2)(3x3)ABCF(8x2)(3x3)ABCY`<br>`XF(3x3)ABC(3x3)ABCF(3x3)ABC(3x3)ABCY`

### Task 8: Into the future

Your business now is booming. Even the mobile markets are yours, and there are no hackers that can face you. It is time to do what you wanted to do all this time. What was it?

Create an application that does something that you want it to do.
